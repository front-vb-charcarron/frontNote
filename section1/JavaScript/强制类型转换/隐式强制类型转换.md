#隐式强制类型转换
>##### 隐式强制类型转换指的是那些隐藏的强制类型转换，副作用也不是很明显。换句话说，你自己觉得不够明显的强制类型转换都可以算作隐式强制类型转换。

###1. 字符串和数字之间的隐式强制类型转换
#####1.1.通过重载，`+`运算符既能用于数字加法，也能用于字符串拼接：
```
	var a = "42";
	var b = "0";
	
	var c = 42;
	var d = 0;
	
	a + b; // "420"
	c + d; // 42
```
#####假如a和b都不是字符串，但它们会被强制转换为字符串然后比较：
```
	var a = [1,2];
	var b = [3,4];
	
	a + b; // "1,23,4"
```
>#####因为使用了`+`运算符，此时a和b会根据`ToPrimitive抽象操作`变成基本类型(字符串)进行字符串拼接。

#####如果是`-`、`*`、`/`(适用于数字的运算符)进运算：
```
	var a = [3];
	var b = [1];
	
	a - b; // 2
```
>#####为了执行减法运算，a和b都需要被转换成数字，它们首先被转换为字符串(通过`toString()`),然后再转为数字进行运算。

###2. 布尔值到数字的隐式强制类型转换
>##### `true`转为1，`false`转为0。

###3. 隐式强制类型转换为布尔值
#####3.1. 下面的情况会发生布尔值隐式强制类型转换。
#####(1)if (..)语句中的条件判断表达式。
#####(2)for (..;..;..)语句中的条件判断表达式(第二个)。
#####(3)while (..)和do..while(..)循环中的条件表达式。
#####(4)? :中的条件判断表达式。
#####(5)逻辑运算符|| (逻辑或) 和&& (逻辑与) 左边的操作数 (作为条件判断表达式)。

#####以上情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的ToBoolean抽象操作规则。

###4. 宽松相等和严格相等
>#####宽松相等`==`和严格相等`===`都是用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断上。正确的解释是：“`==`允许在相等的比较重进行强制类型转换，而`===`不允许。”`==`会比`===`要慢个百万分之一秒，可以忽略不计。

###5. 抽象相等
>#####ES5规范11.9.3节的“抽象相等比较算法”定义了`==`运算符的行为, `==`在比较两个不同类型的值时会发生隐式强制类型转换，会将其中之一或两者转换为相同类型后再进行比较。

#####5.1 有几个非常规的情况需要注意：
+`NaN`不等与`NaN`
+`+0`不等于`-0`
